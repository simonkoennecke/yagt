%Dokumententyp
\documentclass[a4paper]{article}

\usepackage[a4paper,left=2cm, right=3cm, top=2cm]{geometry}

%Kodierung
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%Grafiken einbinden
\usepackage{graphicx}
\usepackage{subfigure} 

%Position von Grafiken und Tabellen erzwingen:
\usepackage{float}

%URLs im Literaturverzeichnis
\usepackage{url}

\usepackage{amsmath}

%Vektoren einfacher angeben:
\newcommand{\vektor}[1]{\left( \begin{array}{c} #1 \end{array} \right) }


%Schriftart Arial:
% \usepackage{helvet}

%Figures with text around it:
\usepackage{wrapfig}

\usepackage{listings}

%seitennummern rechts:
% \usepackage{fancyhdr}
% \fancyhf{} % clear all header and footers
% \renewcommand{\headrulewidth}{0pt} % remove the header rule
% \rfoot{\thepage}
% \fancypagestyle{plain}{%redefining plain pagestyle
% \fancyhf %clear all headers and footers fields
% \fancyhead[R]{\thepage} %prints the page number on the right side of the header
% }

%Schriftart Times New Roman "like"
\usepackage{txfonts}

%Sprache
\usepackage[german]{babel}

%Checkmarks: (usage: \checkmark)
\usepackage{dingbat}

\usepackage{listings}
\usepackage{color}
\definecolor{javared}{rgb}{0.6,0,0} % for strings
\definecolor{javagreen}{rgb}{0.25,0.5,0.35} % comments
\definecolor{javapurple}{rgb}{0.5,0,0.35} % keywords
\definecolor{javadocblue}{rgb}{0.25,0.35,0.75} % javadoc
 
\lstset{language=Java,
basicstyle=\ttfamily,
keywordstyle=\color{javapurple}\bfseries,
stringstyle=\color{javared},
commentstyle=\color{javagreen},
morecomment=[s][\color{javadocblue}]{/**}{*/},
numbers=left,
numberstyle=\tiny\color{black},
stepnumber=1,
numbersep=5pt,
tabsize=4,
showspaces=false,
lineskip={-1.5pt},
showstringspaces=false}

%Tabellenextras
\usepackage{tabularx}

%Zeilenabstand 1.5
\linespread{1.5}
\usepackage{setspace}

%Figure Captions mit Fußnoten
\usepackage{footnote}
%\setlength{\parindent}{0pt} 

%Graphen/Trees zeichnen:
\usepackage{tikz}


%itemize items richtig ausrichten (nicht links überlappen!)
% \setlist{leftmargin=0}

% %%%%TITELSEITE%%%%%%(
% \title{ Konzept und Implementierung\\ eines Systems zur \\Anforderung und Verwaltung von virtuellen privaten Clustern}
% \author{\textbf{\large Bachelorarbeit}}
% 
% \date{zur Erlangung des akademischen Grades Bachelor of Science an der Universität Paderborn im Fachbereich Informatik im Studiengang Bachelor Informatik}

% %%%%TITELSEITE%%%%%%)

% \pagestyle{fancy}
\begin{document}

\title{Algorithmische Geometrie - Sommersemester 2015\\
       8. Aufgabenblatt }
\author{Simon Koennecke und Felix Bröker}
\date{}
\maketitle

\section*{Aufgabe 1 - Vorverarbeitungszeit für Bereichsbäume}

Im folgenden sehen wir uns zunächst in Pseudocode an, 
wie ein 2d-Bereichsbaum aufgebaut werden kann:

\begin{lstlisting}
Eingabe: pX, pY (nach x- bzw. y-Koordinate sortiertes Array der Punkte aus P)
Ausgabe: Wurzelknoten des 2d-Bereichbaums

Create-2d-Range-Tree(pX, pY)
IF size(pX) == 0
	return NULL;
ELSE
	yTree = Create-1d-Range-Tree(pX, pY);

IF size(pX) == 1
	return new Node(pX[1], yTree, NULL, NULL);
ELSE
	pY1 = updatepY(pX[1..ceiling(size(pX)/2)], pY);
	pY2 = updatepY(ceiling(pX[size(pX)/2)+1..size(pX)], pY);
	leftNode  = Create-2d-Range-Tree(pX[1..ceiling(size(pX)/2)], pY1);
	rightNode = Create-2d-Range-Tree(ceiling(pX[size(pX)/2)+1..size(pX)], pY2);
	return new Node(ceiling(pX[size(pX)/2]), yTree, leftNode, rightNode);
\end{lstlisting}

Die 4 Parameter von "`Node"' geben dabei den zu speichernden x-Wert (der jeweilige Median), 
den zum Knoten zugehörigen 1d-Bereichsbaum (bzgl. der y-Koordinaten der zugehörigen Punkte),
den linken, sowie rechten Kindknoten an. "`Create-1d-Range-Tree(pX, pY)"' erstellt einen 1d-Bereichsbaum für alle Punkte in pX nach deren y-Koordinate. 
Die Funktion updatepY(pX, pY) reduziert die Menge pY jeweils um die nicht in pX enthaltenen Punkte.
Dieser Vorgang benötigt $\mathcal{O}(size(pX))$ viele Operationen.

\subsection*{Laufzeitabschätzung}
Zur Laufzeitabschätzung stellen wir folgende Rekursionsgleichungen auf:
$$T(\leq 1) = \mathcal{O}(1)$$
Im Fall von $n \leq 1$ (Rekursionsanker) haben wir eine konstante Laufzeit.
Dies können wir auch an obigem Pseudocode ablesen. Ist die Eingabegröße $ n < 1$ bzw. $n = 0$
wird lediglich ein "`NULL"'-Element zurückgegeben. Im Fall $n = 1$ wird lediglich ein neuer Knoten
und dessen 1-elementiger 1d-Range-Tree (ebenfalls konstante Zeit) angelegt und zurückgegeben. 
In allen anderen Fällen setzt sich die Laufzeit aus der Zeit für die Konstruktion eines 1d-Range-Trees
(Zeile 8), der Zeit zur Reduzierung der Menge pY (Zeilen 13, 14), der Zeit für den Aufruf beider Rekursionen (Zeilen 15,16) und der Erstellung des Rückgabeknotens (Zeile 17) zusammen:

$$T(n) = T(\lfloor n/2\rfloor) + T(\lceil n/2\rceil) + \underbrace{\mathcal{O}(n) + \mathcal{O}(n) + \mathcal{O}(1)}_{\mathcal{O}(n)}$$

Der 1d-Range-Tree kann mithilfe der 
sortierten Liste pY in O(n) Zeit konstruiert werden. Die grobe Idee zur Lösung in O(n) lässt sich 
wie folgt beschreiben: Es werden je zwei der Knoten am Anfang der Liste entnommen, der entsprechende
Elternknoten erstellt und dieser am Ende der Liste wieder eingefügt, solange bis nur noch ein Knoten
in der Liste enthalten ist. Da die Menge der Knoten eines binären Baums in $\mathcal{O}(n)$ liegt, 
benötigt diese Prozedur ebenfalls $\mathcal{O}(n)$ Zeit. 

 Die Zeit für die Erstellung des Rückgabeknotens inklusive anderer
konstanter Operationen wie z.B. der verwendeten IF-Abfragen kann mit $\mathcal{O}(1)$ abgeschätzt
werden. Da die aktuelle Punktemenge der Größe $n$ anhand ihres Medians geteilt und als Eingabe der
nächsten Rekursionen verwendet werden, und nicht sicher ist, ob $n$ eine 2er-Potenz ist, werden
jeweils die auf- bzw. abgerundeten Hälften der Eingabegröße zur Abschätzung ($T(\lfloor n/2\rfloor)$  und $T(\lceil n/2\rceil)$) verwendet. 

Die aufgestellte Rekursionsgleichung entspricht genau der Rekursionsgleichung wie wir sie von Sortieralgorithmen wie z.B. Mergesort kennen. Für Mergesort ist die Laufzeitabschätzung 
$T(n) = \mathcal{O}(n \log n)$ bekannt. Die hier vorgestellte Berechnung/Konstruktion eines
2d-Range-Trees benötigt also ebenfalls $\mathcal{O}(n \log n)$ Zeit.

\section*{Aufgabe 2 - dynamische Segmentbäume}
Wir haben ein Universum $U$ gegeben. Sei weiterhin ein dynamischer Segmentbaum in Form eines AVL-Baums über diesem Universum gegeben. Dieser beinhaltet bereits eine Menge $I$ von Intervallen. 

Im Folgenden beschreiben wir zunächst das Einfügen eines neuen Intervalls $I_n = [a,b]$:

\begin{itemize}
 \item Fall 1 ( $a \wedge b \in U$ ): 
    Füge $I_n$ nach bekannter Prozedur in den Segmentbaum ein.
 \item Fall 2 ( $a \vee b  \notin U$)
    \begin{itemize}
     \item Erweitere das Universum $U$ wie folgt: $U = U \cup \left\{a,b\right\}$
     \item Aktualisiere den AVL-Baum entsprechend für $a$ bzw. $b$. Dabei werden die in der 
     AVL-Einfügeoperation verwendeten Rotationen wie folgt angepasst/erweitert:
     \begin{itemize}
      \item Im Falle einer Rechts-Rotation:
      
   
      \begin{tikzpicture}
	[scale=.8,auto=left,every node/.style={circle,fill=blue!20}]
	\node (n1) at (5,10) {};
	\node (n2) at (4,8) {};
	\node (n3) at (3,6) {};
	\node (n4) at (6,8) {y};
	\node (n5) at (5,6) {x};
	\node (n6) at (7,6) {$a_3$};
	\node (n7) at (4,4) {$a_1$};
	\node (n8) at (6,4) {$a_2$};
	
	\node (n9) at (12,10) {};
	\node (n10) at (11,8) {};
	\node (n11) at (10,6) {};
	\node (n12) at (13,8) {x};
	\node (n13) at (12,6) {$a_1$};
	\node (n14) at (14,6) {y};
	\node (n15) at (13,4) {$a_2$};
	\node (n16) at (15,4) {$a_3$};


	\foreach \from/\to in {n1/n2,n2/n3,n1/n4,n4/n5,n4/n6,n5/n7,n5/n8, n9/n10,n10/n11,n9/n12,n12/n13,n12/n14,n14/n15,n14/n16}
	  \draw (\from) -- (\to);

      \end{tikzpicture}
      
      Bei der Rechts-Rotation um den Knoten y müssen die jeweils zugeordneten Intervall-Listen
      wie folgt angepasst werden:
    
      \begin{itemize}
       \item Die Intervall-Liste von $a_1$ wird erweitert um die Liste von x, also $L(a_1) = L(a_1) \cup L(x)$
       \item Der Knoten x erhält als neue Intervall-Liste die Liste von y.
       \item Der K
      \end{itemize}

      
      \item Im Falle einer Links-Rotation: Verfahre analog zum Fall einer Rechts-Rotation.
     \end{itemize}

    \end{itemize}

\end{itemize}






\section*{Aufgabe 3 - Punkt-Rechteck-Anfragen}


\end{document}

